spring.application.name=game-recommender-ai

# Временная заглушка TODO: Убрать, когда секьюрити перейдет на реактивную модель (Когда удалим starter web из pom.xml)
# Используем только reactive (Netty), отключаем servlet (Tomcat)
spring.main.web-application-type=reactive
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration

# Server configuration
server.port=8080

# Project version from maven
application.version=@project.version@

# Application configuration
application.base.url=${APPLICATION_BASE_URL:http://localhost:${server.port}}

# gRPC Configuration
grpc.ai-service.host=${GRPC_AI_SERVICE_HOST:localhost}
grpc.ai-service.port=${GRPC_AI_SERVICE_PORT:9090}

# Security configuration
application.security.cookie.refresh-token.name=${REFRESH_TOKEN_COOKIE_NAME:refresh_token}
application.security.cookie.max-age-in-days=${COOKIE_MAX_AGE:${tokens.refresh-token.ttl-in-days}}
# CORS Configuration - список разрешенных origins через запятую
application.security.cors.allowed-origins=${CORS_ALLOWED_ORIGINS:http://localhost:3000,http://localhost:5173}

# gRPC Client Configuration (Spring Boot Starters)
grpc.client.ai-service.address=${grpc.ai-service.host}:${grpc.ai-service.port}
grpc.client.ai-service.negotiationType=plaintext
grpc.client.ai-service.maxInboundMessageSize=1048576

# Security
security.jwt.secret=${JWT_SECRET:your-jwt-secret-i-dont-remember-how-long-it-should-be-but-this-should-be-long-enough}

# Tokens
tokens.access-token.ttl-in-minutes=15
tokens.refresh-token.ttl-in-days=3

# Rate limiting
performance.rate-limiter.role.limit.of-hour.GUEST_USER=5
performance.rate-limiter.role.limit.of-hour.USER=10

# Cache settings
spring.cache.cache-names[0]=rate-limit-buckets
spring.cache.cache-names[1]=filter-config-cache

# Bucket4j settings
bucket4j.enabled=true
bucket4j.filter-config-caching-enabled=true
bucket4j.filter-config-cache-name=filter-config-cache
bucket4j.default-http-response-body={"error": "Rate limit exceeded"}
bucket4j.cache-to-use=redis-lettuce
bucket4j.async=false

# Settings for guest rate limiting
bucket4j.filters[0].id=guest-rate-limit
bucket4j.filters[0].cache-name=rate-limit-buckets
bucket4j.filters[0].filter-order=100
bucket4j.filters[0].url=/test
bucket4j.filters[0].strategy=first

bucket4j.filters[0].metrics.enabled=true
bucket4j.filters[0].metrics.tags[0].key=IP
bucket4j.filters[0].metrics.tags[0].expression=getRemoteAddr()
bucket4j.filters[0].metrics.tags[1].key=USER_ROLE
bucket4j.filters[0].metrics.tags[1].expression='GUEST'

bucket4j.filters[0].rate-limits[0].execute-condition=@bucketUtil.getUserRole().equals('GUEST')
bucket4j.filters[0].rate-limits[0].cache-key=@requestOnBucketRouter.getBucketCacheKey() + getRemoteAddr()
bucket4j.filters[0].rate-limits[0].bandwidths[0].capacity=${performance.rate-limiter.role.limit.of-hour.GUEST_USER:5}
bucket4j.filters[0].rate-limits[0].bandwidths[0].time=1
bucket4j.filters[0].rate-limits[0].bandwidths[0].unit=hours
bucket4j.filters[0].rate-limits[0].bandwidths[0].refill-speed=interval
bucket4j.filters[0].rate-limits[0].bandwidths[0].id=guest-hourly

# Settings for simple user rate limiting
bucket4j.filters[1].id=simple-user-rate-limit
bucket4j.filters[1].cache-name=rate-limit-buckets
bucket4j.filters[1].filter-order=100
bucket4j.filters[1].url=/test
bucket4j.filters[1].strategy=first

bucket4j.filters[1].metrics.enabled=true
bucket4j.filters[1].metrics.tags[0].key=SUBJECT
bucket4j.filters[1].metrics.tags[0].expression=@bucketUtil.getUsername()
bucket4j.filters[1].metrics.tags[1].key=USER_ROLE
bucket4j.filters[1].metrics.tags[1].expression='USER'

bucket4j.filters[1].rate-limits[0].execute-condition=@bucketUtil.getUserRole().equals('USER')
bucket4j.filters[1].rate-limits[0].cache-key=@requestOnBucketRouter.getBucketCacheKey()
bucket4j.filters[1].rate-limits[0].bandwidths[0].capacity=${performance.rate-limiter.role.limit.of-hour.USER:20}
bucket4j.filters[1].rate-limits[0].bandwidths[0].time=1
bucket4j.filters[1].rate-limits[0].bandwidths[0].unit=hours
bucket4j.filters[1].rate-limits[0].bandwidths[0].refill-speed=interval
bucket4j.filters[1].rate-limits[0].bandwidths[0].id=simple-user-hourly

# Dev DB
spring.r2dbc.url=${SPRING_DATASOURCE_URL:r2dbc:postgresql://localhost:5433/game_recommender_ai_db?schema=game_recommender}
spring.r2dbc.username=${SPRING_DATASOURCE_USERNAME:postgres}
spring.r2dbc.password=${SPRING_DATASOURCE_PASSWORD:password}

# Swagger/OpenAPI Configuration
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.enabled=true
springdoc.api-docs.enabled=true
springdoc.swagger-ui.disable-swagger-default-url=true
springdoc.swagger-ui.persistAuthorization=true
springdoc.paths-to-match=/api/**

# Spring Boot Actuator Configuration
management.endpoints.web.base-path=/actuator
management.endpoints.web.exposure.include=health,info,metrics,prometheus,env,configprops
management.endpoint.health.show-details=always
management.endpoint.health.show-components=always
management.info.env.enabled=true
management.info.git.enabled=true
management.metrics.distribution.percentiles-histogram.http.server.requests=true

# Custom health indicators
management.health.defaults.enabled=true
management.health.diskspace.enabled=true
management.health.db.enabled=true

# Metrics configuration
management.simple.metrics.export.enabled=true
management.metrics.tags.application=${spring.application.name}

# Prometheus configuration
management.prometheus.metrics.export.enabled=true

# Logging
logging.level.ru.perevalov.gamerecommenderai=DEBUG
logging.level.org.springframework.web=DEBUG
logging.level.io.grpc=DEBUG

logging.level.io.grpc.internal.ManagedChannelImplBuilder=ERROR
logging.level.io.grpc.internal=ERROR
logging.level.io.grpc.ManagedChannelRegistry=ERROR
logging.level.io.grpc.netty.shaded.io.grpc.netty.Utils=WARN

logging.level.root=INFO
logging.level.org.hibernate=WARN
logging.level.org.springframework=WARN

# Убирает сообщение про ContextStorageOverride
logging.level.io.grpc.Context=ERROR

# Урезаем подробный DEBUG от netty (shaded)
logging.level.io.grpc.netty.shaded.io.grpc.netty=INFO

#Steam
steam.user.apiKey=${STEAM_API_KEY}
steam.user.scheme=https
steam.user.host=api.steampowered.com
steam.user.getPlayerSummariesPath=/ISteamUser/GetPlayerSummaries/v0002/
steam.user.getOwnedGamesPath=/IPlayerService/GetOwnedGames/v0001/
steam.user.retryAttempts=3
steam.user.retryDelaySeconds=2

steam.store.scheme=https
steam.store.host=store.steampowered.com
steam.store.getAppDetailsPath=/api/appdetails
steam.store.retryAttempts=10
steam.store.retryDelaySeconds=5

steam.api.scheme=https
steam.api.host=api.steampowered.com
steam.api.getAppListPath=/ISteamApps/GetAppList/v2
steam.api.retryAttempts=3
steam.api.retryDelaySeconds=10
steam.api.maxInMemorySize=20971520
steam.api.durationOfMinutes=3
steam.api.jitter=0.5
steam.api.connectTimeoutMillis=50000

# Steam login url
steam.openid.endpoint=https://steamcommunity.com/openid/login

# Header parameters names
requestid.header.key=rquid

# Request id logging param
requestid.logging.param=RequestID

# Redis
redis.redis-uri=redis://localhost:6379
redis.bucket-key=steam-api-global-bucket
redis.capacity=50
redis.tokens-per-refill=10
redis.refill-duration=PT1S
redis.bucket-ttl=PT10M
redis.cache.key=steam_apps

# Liquibase
spring.liquibase.change-log=classpath:/db/changelog/changelog-master.xml
spring.liquibase.driver-class-name=org.postgresql.Driver

# Scheduled
app.scheduler.update-steam-apps.cron=0 0 2 ? * SUN

#saveToDatabase
app.batch.size=10000
app.batch.concurrency=8

